'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _path = require('path');

var _fs = require('fs');

var _stripBom = require('strip-bom');

var _stripBom2 = _interopRequireDefault(_stripBom);

var _sourceMapSupport = require('source-map-support');

var _sourceMapSupport2 = _interopRequireDefault(_sourceMapSupport);

var _loadBabelLibs3 = require('./load-babel-libs');

var _loadBabelLibs4 = _interopRequireDefault(_loadBabelLibs3);

var _testFile = require('../../api/structure/test-file');

var _testFile2 = _interopRequireDefault(_testFile);

var _fixture = require('../../api/structure/fixture');

var _fixture2 = _interopRequireDefault(_fixture);

var _test = require('../../api/structure/test');

var _test2 = _interopRequireDefault(_test);

var _runtime = require('../../errors/runtime');

var _stackCleaningHook = require('../../errors/stack-cleaning-hook');

var _stackCleaningHook2 = _interopRequireDefault(_stackCleaningHook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EXPORTABLE_LIB_PATH = (0, _path.join)(__dirname, '../../api/exportable-lib');
var CWD = process.cwd();

var FIXTURE_RE = /(^|;|\s+)fixture\s*(\.|\(|`)/;
var TEST_RE = /(^|;|\s+)test\s*(\.|\()/;
var BABEL_RUNTIME_RE = /^babel-runtime(\\|\/|$)/;

var Module = module.constructor;

var ESNextCompiler = function () {
    function ESNextCompiler() {
        (0, _classCallCheck3.default)(this, ESNextCompiler);

        this.sourceMaps = {};
        this.cache = {};

        this._setupSourceMapsSupport();
    }

    ESNextCompiler._getNodeModulesLookupPath = function _getNodeModulesLookupPath(filename) {
        var dir = (0, _path.dirname)(filename);

        return Module._nodeModulePaths(dir);
    };

    ESNextCompiler._getBabelOptions = function _getBabelOptions(filename) {
        var _loadBabelLibs = (0, _loadBabelLibs4.default)(),
            presetStage2 = _loadBabelLibs.presetStage2,
            transformRuntime = _loadBabelLibs.transformRuntime,
            presetEnv = _loadBabelLibs.presetEnv;

        // NOTE: passPrePreset and complex presets is a workaround for https://github.com/babel/babel/issues/2877
        // Fixes https://github.com/DevExpress/testcafe/issues/969


        return {
            passPerPreset: true,
            presets: [{
                passPerPreset: false,
                presets: [{ plugins: [transformRuntime] }, presetStage2, presetEnv]
            }],
            filename: filename,
            sourceMaps: true,
            retainLines: true,
            ast: false,
            babelrc: false,
            highlightCode: false,

            resolveModuleSource: function resolveModuleSource(source) {
                if (source === 'testcafe') return EXPORTABLE_LIB_PATH;

                if (BABEL_RUNTIME_RE.test(source)) {
                    try {
                        return require.resolve(source);
                    } catch (err) {
                        return source;
                    }
                }

                return source;
            }
        };
    };

    ESNextCompiler._isNodeModulesDep = function _isNodeModulesDep(filename) {
        return (0, _path.relative)(CWD, filename).split(_path.sep).indexOf('node_modules') >= 0;
    };

    ESNextCompiler._execAsModule = function _execAsModule(code, filename) {
        var mod = new Module(filename, module.parent);

        mod.filename = filename;
        mod.paths = ESNextCompiler._getNodeModulesLookupPath(filename);

        mod._compile(code, filename);
    };

    ESNextCompiler.prototype._setupSourceMapsSupport = function _setupSourceMapsSupport() {
        var _this = this;

        _sourceMapSupport2.default.install({
            handleUncaughtExceptions: false,
            environment: 'node',

            retrieveSourceMap: function retrieveSourceMap(filename) {
                var map = _this.sourceMaps[filename];

                return map ? { url: filename, map: map } : null;
            }
        });
    };

    ESNextCompiler.prototype._compileES = function _compileES(code, filename) {
        var _loadBabelLibs2 = (0, _loadBabelLibs4.default)(),
            babel = _loadBabelLibs2.babel;

        if (this.cache[filename]) return this.cache[filename];

        var opts = ESNextCompiler._getBabelOptions(filename);
        var compiled = babel.transform(code, opts);

        this.cache[filename] = compiled.code;
        this.sourceMaps[filename] = compiled.map;

        return compiled.code;
    };

    ESNextCompiler.prototype._setupRequireHook = function _setupRequireHook(testFile) {
        var _this2 = this;

        var origRequireExtension = require.extensions['.js'];

        require.extensions['.js'] = function (mod, filename) {
            // NOTE: remove global API so that it will be unavailable for the dependencies
            _this2._removeGlobalAPI();

            if (ESNextCompiler._isNodeModulesDep(filename)) origRequireExtension(mod, filename);else {
                var code = (0, _fs.readFileSync)(filename);
                var compiledCode = _this2._compileES((0, _stripBom2.default)(code), filename);

                mod.paths = ESNextCompiler._getNodeModulesLookupPath(filename);

                mod._compile(compiledCode, filename);
            }

            _this2._addGlobalAPI(testFile);
        };

        return origRequireExtension;
    };

    ESNextCompiler.prototype._compileESForTestFile = function _compileESForTestFile(code, filename) {
        var compiledCode = null;

        _stackCleaningHook2.default.enabled = true;

        try {
            compiledCode = this._compileES(code, filename);
        } catch (err) {
            throw new _runtime.TestCompilationError(err);
        } finally {
            _stackCleaningHook2.default.enabled = false;
        }

        return compiledCode;
    };

    ESNextCompiler.prototype._addGlobalAPI = function _addGlobalAPI(testFile) {
        Object.defineProperty(global, 'fixture', {
            get: function get() {
                return new _fixture2.default(testFile);
            },
            configurable: true
        });

        Object.defineProperty(global, 'test', {
            get: function get() {
                return new _test2.default(testFile);
            },
            configurable: true
        });
    };

    ESNextCompiler.prototype._removeGlobalAPI = function _removeGlobalAPI() {
        delete global.fixture;
        delete global.test;
    };

    ESNextCompiler.prototype.canCompile = function canCompile(code, filename) {
        return (/\.js$/.test(filename) && FIXTURE_RE.test(code) && TEST_RE.test(code)
        );
    };

    ESNextCompiler.prototype.compile = function compile(code, filename) {
        var compiledCode = this._compileESForTestFile(code, filename);
        var testFile = new _testFile2.default(filename);

        this._addGlobalAPI(testFile);

        _stackCleaningHook2.default.enabled = true;

        var origRequireExtension = this._setupRequireHook(testFile);

        try {
            ESNextCompiler._execAsModule(compiledCode, filename);
        } catch (err) {
            // HACK: workaround for the `instanceof` problem
            // (see: http://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node)
            if (err.constructor !== _runtime.APIError) throw new _runtime.TestCompilationError(err);

            throw err;
        } finally {
            require.extensions['.js'] = origRequireExtension;
            _stackCleaningHook2.default.enabled = false;

            this._removeGlobalAPI();
        }

        return testFile.getTests();
    };

    ESNextCompiler.prototype.cleanUpCache = function cleanUpCache() {
        this.cache = null;
    };

    return ESNextCompiler;
}();

exports.default = ESNextCompiler;
module.exports = exports['default'];