'use strict';

exports.__esModule = true;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _Object$assign2, _responseForced;

exports.forRequest = forRequest;
exports.forResponse = forResponse;

var _headers = require('./xhr/headers');

var _headers2 = _interopRequireDefault(_headers);

var _authorization = require('./xhr/authorization');

var _authorization2 = _interopRequireDefault(_authorization);

var _url = require('../utils/url');

var urlUtils = _interopRequireWildcard(_url);

var _url2 = require('url');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Skipping transform
function skip() {
    return void 0;
}

function isCrossDomainXhrWithoutCredentials(ctx) {
    return ctx.isXhr && !!ctx.req.headers[_headers2.default.corsSupported] && !ctx.req.headers[_headers2.default.withCredentials] && ctx.dest.reqOrigin !== ctx.dest.domain;
}

function transformAuthorizationHeader(src, ctx) {
    if (src.indexOf(_authorization2.default.valuePrefix) !== -1) return src.replace(_authorization2.default.valuePrefix, '');

    return isCrossDomainXhrWithoutCredentials(ctx) ? void 0 : src;
}

function transformCookieForFetch(src, ctx) {
    var requestCredentials = ctx.req.headers[_headers2.default.fetchRequestCredentials];

    switch (requestCredentials) {
        case 'omit':
            return void 0;
        case 'same-origin':
            return ctx.dest.reqOrigin === ctx.dest.domain ? src : void 0;
        case 'include':
            return src;
        default:
            return void 0;
    }
}

function transformCookie(src, ctx) {
    if (ctx.isXhr) return isCrossDomainXhrWithoutCredentials(ctx) ? void 0 : src;else if (ctx.isFetch) return transformCookieForFetch(src, ctx);

    return src;
}

// Request headers
var requestTransforms = (0, _assign2.default)((_Object$assign2 = {
    'host': function host(src, ctx) {
        return ctx.dest.host;
    },
    'referer': function referer(src, ctx) {
        return ctx.dest.referer || void 0;
    },
    'origin': function origin(src, ctx) {
        return ctx.dest.reqOrigin || src;
    },
    'content-length': function contentLength(src, ctx) {
        return ctx.reqBody.length;
    },
    'cookie': skip
}, _Object$assign2[_headers2.default.requestMarker] = skip, _Object$assign2[_headers2.default.corsSupported] = skip, _Object$assign2[_headers2.default.withCredentials] = skip, _Object$assign2[_headers2.default.origin] = skip, _Object$assign2[_headers2.default.fetchRequestCredentials] = skip, _Object$assign2), _authorization2.default.headers.reduce(function (obj, header) {
    obj[header] = transformAuthorizationHeader;

    return obj;
}, {}));

var requestForced = {
    'cookie': function cookie(src, ctx) {
        return transformCookie(ctx.session.cookies.getHeader(ctx.dest.url) || void 0, ctx);
    },

    // NOTE: All browsers except Chrome don't send the 'Origin' header in case of the same domain XHR requests.
    // So, if the request is actually cross-domain, we need to force the 'Origin' header to support CORS. (B234325)
    'origin': function origin(src, ctx) {
        var force = (ctx.isXhr || ctx.isFetch) && !src && ctx.dest.domain !== ctx.dest.reqOrigin;

        return force ? ctx.dest.reqOrigin : src;
    }
};

// Response headers
var responseTransforms = {
    'set-cookie': function setCookie(src, ctx) {
        if (src) {
            var cookies = Array.isArray(src) ? src : [src];

            cookies = cookies.filter(function (cookieStr) {
                return !!cookieStr;
            });
            ctx.session.cookies.setByServer(ctx.dest.url, cookies);
        }

        // NOTE: Delete header.
        return void 0;
    },

    // NOTE: Disable Content Security Policy (see http://en.wikipedia.org/wiki/Content_Security_Policy).
    'content-security-policy': skip,
    'content-security-policy-report-only': skip,
    'x-content-security-policy': skip,
    'x-content-security-policy-report-only': skip,
    'x-webkit-csp': skip,

    // NOTE: Even if we are not able to be authorized, we should prevent showing the native credentials window.
    'www-authenticate': skip,

    // NOTE: We perform CORS checks on our side, so we skip the related headers.
    'access-control-allow-origin': skip,

    // NOTE: Change the transform type if we have an iframe with an image as src,
    // because it was transformed to HTML with the image tag.
    'content-type': function contentType(src, ctx) {
        return ctx.contentInfo.isIframeWithImageSrc ? 'text/html' : src;
    },
    'content-length': function contentLength(src, ctx) {
        return ctx.contentInfo.requireProcessing ? ctx.destResBody.length : src;
    },

    'location': function location(src, ctx) {
        // NOTE: The RFC 1945 standard requires location URLs to be absolute. However, most popular browsers
        // accept relative URLs. We transform relative URLs to absolute to correctly handle this situation.
        var _parseUrl = (0, _url2.parse)(src);

        var host = _parseUrl.host;


        if (!host) src = (0, _url2.resolve)(ctx.dest.url, src);

        var isCrossDomain = ctx.isIframe && !urlUtils.sameOriginCheck(ctx.dest.url, src);

        return ctx.toProxyUrl(src, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);
    },

    'x-frame-options': function xFrameOptions(src, ctx) {
        if (src.indexOf('ALLOW-FROM') === -1) return src;

        src = src.replace('ALLOW-FROM', '').trim();

        var isCrossDomain = ctx.isIframe && !urlUtils.sameOriginCheck(ctx.dest.url, src);
        var proxiedUrl = ctx.toProxyUrl(src, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);

        return 'ALLOW-FROM ' + proxiedUrl;
    }
};

var responseForced = (_responseForced = {}, _responseForced[_headers2.default.setCookie] = function (src, ctx) {
    if (ctx.isXhr && ctx.destRes && ctx.destRes.headers && ctx.destRes.headers['set-cookie']) {
        var setCookieHeader = ctx.destRes.headers['set-cookie'];
        var cookieArr = Array.isArray(setCookieHeader) ? setCookieHeader : [setCookieHeader];

        return (0, _stringify2.default)(cookieArr);
    }

    return void 0;
}, _responseForced);

// Transformation routine
function transformHeaders(srcHeaders, ctx, transformList, forced) {
    var destHeaders = {};

    var applyTransform = function applyTransform(headerName, headers, transforms) {
        var src = headers[headerName];
        var transform = transforms[headerName];
        var dest = transform ? transform(src, ctx) : src;

        if (dest !== void 0) destHeaders[headerName] = dest;
    };

    (0, _keys2.default)(srcHeaders).forEach(function (headerName) {
        return applyTransform(headerName, srcHeaders, transformList);
    });

    if (forced) (0, _keys2.default)(forced).forEach(function (headerName) {
        return applyTransform(headerName, destHeaders, forced);
    });

    return destHeaders;
}

// API
function forRequest(ctx) {
    return transformHeaders(ctx.req.headers, ctx, requestTransforms, requestForced);
}

function forResponse(ctx) {
    return transformHeaders(ctx.destRes.headers, ctx, responseTransforms, responseForced);
}